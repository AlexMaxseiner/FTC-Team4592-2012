// #pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
// #pragma config(Sensor, S1,     ,               sensorI2CMuxController)
// #pragma config(Sensor, S4,     liftSafetyTouch, sensorTouch)
// #pragma config(Motor,  mtr_S1_C1_1,     rightDrive,    tmotorTetrix, openLoop, encoder)
// #pragma config(Motor,  mtr_S1_C1_2,     leftDrive,     tmotorTetrix, openLoop, reversed, encoder)
// #pragma config(Motor,  mtr_S1_C2_1,     slide,         tmotorTetrix, openLoop, reversed, encoder)
// #pragma config(Motor,  mtr_S1_C2_2,     lift,          tmotorTetrix, openLoop, reversed, encoder)
// #pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
// #pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
// #pragma config(Servo,  srvo_S1_C3_3,    clawservo,            tServoStandard)
// #pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
// #pragma config(Servo,  srvo_S1_C3_5,    leftgrab,             tServoStandard)
// #pragma config(Servo,  srvo_S1_C3_6,    rightgrab,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#ifndef Rigid
#define Rigid
#include "main.c"

void forward(float distance); //distance in inches
void run();
void turn(float degrees); //turns 'degrees' degrees right

void rigid() {
	forward(48);
	turn(15);
	foreward(36);
	turn(-15);
}

void turn(float degrees) {
	const float fullturn = 10498;//encoder value for 360 degrees

	float power = 50;
	float turn = degrees*(10498/360);
	while(abs(nMotorEncoder[leftDrive]) < turn && abs(nMotorEncoder[rightDrive]) < turn) {
		if(degrees > 0) {
			motor[leftPower] = -1*power;
			motor[rightDrive] = power;
		}
		else {
			motor[leftDrive] = power;
			motor[rightDrive] = -1*power;
		}
	}
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

void forward(float distance) {//forward function to pass in a length in inches and then it goes that for
	const float CHANGE = 2;
	float totalTraveled = 0;
	float encoderTarget = (169.92*distance) - 55.875; //calculate the encoder target
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive]  = 0;
	float leftEncoder;
	float rightEncoder;
	float leftPower  = 50;
	float rightPower = 50;
	while(abs(totalTraveled) < abs(encoderTarget))
	{
		leftEncoder  = nMotorEncoder[leftDrive];
		rightEncoder = nMotorEncoder[rightDrive];
		if(leftEncoder > rightEncoder)//changes based on which one has traveled farther
		{
			leftPower  -= CHANGE;
			rightPower += CHANGE;
		}
		else if(leftEncoder < rightEncoder)//same thing
		{
			leftPower  += CHANGE;
			rightPower -= CHANGE;
		}
		motor[leftDrive]  = leftPower;
		motor[rightDrive] = rightPower;
		totalTraveled += (leftEncoder + rightEncoder)/ 2.0;
		nMotorEncoder[rightDrive] = 0;
		nMotorEncoder[leftDrive]  = 0;
		ClearTimer(T1);
		while(time1[T1] < 200) {
			leftEncoder  = nMotorEncoder[leftDrive];
			rightEncoder = nMotorEncoder[rightDrive];
			if(!((abs(totalTraveled + (leftEncoder + rightEncoder)/ 2.0)/* average*/)/*adds the distance traveled*/ < abs(encoderTarget)))
			{//while all that is not less than the encoder target
				totalTraveled += (nMotorEncoder[leftDrive] + nMotorEncoder[rightDrive])/ 2.0;// add the aveage of the encoders
				break;//exit
			}
		}
	}

	motor[leftDrive]  = 0;
	motor[rightDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive]  = 0;
}
#endif